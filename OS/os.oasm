.text

OUT 'o'
OUT 'l'
OUT 'a'
OUT 'f'
OUT 'v'
OUT '2'
OUT 10

boot_msg:
    OUT 'H'
    OUT 'e'
    OUT 'l'
    OUT 'l'
    OUT 'o'
    OUT 0x20
    OUT 'u'
    OUT 's'
    OUT 'e'
    OUT 'r'
    OUT '!'
    OUT 10
    OUT 'e'
    OUT 'n'
    OUT 't'
    OUT 'e'
    OUT 'r'
    OUT 0x20
    OUT 'u'
    OUT 's'
    OUT 'e'
    OUT 'r'
    OUT 'n'
    OUT 'a'
    OUT 'm'
    OUT 'e'
    OUT ':'
    OUT 0x20
    CALL @blocking_read

prompt:
    MOV $RDI, 0
    CALL @print
    OUT '@'
    OUT 'O'
    OUT 'L'
    OUT 'A'
    OUT 'F'
    OUT 'v'
    OUT '2'
    OUT '#'
    OUT 0x20

read_command:
    MOV $RDI, 0x30
    CALL @blocking_read

parse_command:
    MOV $RB, 0x30
    LOAD $RC
    TEST $RC, 'r'
    JEQ @shutdown
    JMP @prompt

shutdown:
    OUT 'b'
    OUT 'y'
    OUT 'b'
    RST
    
; get tow arguments, 2 pointers to strings to compare
; gets one parameter, a number to print
print_number:
    PUSH $RDI
    TEST $RDI, 100
    JST @__print_number__ST_100
    __print_number__BT_100:
        ; get Xxx digit
        DIV $RDI, 100
        ; make printable
        PUSH $RDI
        POP $RD
        ADD $RD, 0x30
        ; print
        OUT
        JMP @__print_number__BT_10
    
    __print_number__ST_100:
        TEST $RDI, 10
        JST @__print_number__ST_10
        __print_number__BT_10:
            POP $RDI
            PUSH $RDI
            ; get xXx digit
            MOD $RDI, 100
            DIV $RDI, 10
            ; make printable
            PUSH $RDI
            POP $RD
            ADD $RD, 0x30
            ; print 
            OUT

    __print_number__ST_10:
        ; get xxX digit
        POP $RDI
        MOD $RDI, 10
        ; make printable
        PUSH $RDI
        POP $RD
        ; print 
        ADD $RD, 0x30
        OUT

    ; return 
    RET

; gets 1 argument, the initial location for the data
blocking_read:
    PUSH $RDI
    POP $RB
    __blocking_read__get_char:
        GET $RD
        TEST $RD, 0
        JEQ @__blocking_read__get_char
        OUT
        TEST $RD, 10
        JEQ @__blocking_read__return
        __blocking_read__not_zero:
            STOR $RD
            ADD $RB, 1
        JMP @__blocking_read__get_char
    __blocking_read__return:
        RET
    
; gets 1 argument, the initial position of the data
print:
    PUSH $RDI
    POP $RB
    __print__get_char:
        LOAD $RD
        TEST $RD, 0
        JEQ @__print__ret
        __print__not_zero:
            OUT
            ADD $RB, 1
        JMP @__print__get_char
    __print__ret:
    RET