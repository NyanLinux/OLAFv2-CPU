; This is the Operating System for OLAFv2, written by Itay Saadia (2019).

.rodata
; this section will create an image of the RAM that contains a block of 
; data in the beginning of the memory.

; strings 
string OS_NAME = "OLAFv2"
string GET_USERNAME = "enter username: "

; commands
string ls = "ls"
string rm = "rm"
string cat = "cat"
string cls = "cls"
string edit = "edit"
string reset = "reset"

.text

boot_msg:
    MOV $RDI, #OS_NAME
    CALL @print
    OUT 10

get_username:
    MOV $RDI, #GET_USERNAME
    CALL @print
    NOP
    MOV $RDI, #DATA_START
    CALL @blocking_read

prompt:
    MOV $RDI, #DATA_START
    CALL @print
    OUT '@'
    MOV $RDI, #OS_NAME
    CALL @print
    OUT '#'
    OUT 0x20

read_command:
    MOV $RDI, 0x90
    CALL @blocking_read

parse_command:
    NOP
    MOV $RDI, 0x90
    NOP
    MOV $RSI, #cls
    CALL @strcmp
    TEST $RA, 1
    JEQ @__parse_command__call_cls
    NOP
    MOV $RDI, 0x90
    NOP
    MOV $RSI, #reset
    CALL @strcmp
    TEST $RA, 1
    JEQ @__parse_command__call_reset
    __parse_command__jmp_prompt:
        JMP @prompt
    __parse_command__call_cls:
        CALL @cls
        JMP @prompt
    __parse_command__call_reset:
        CALL @reset

reset:
    OUT 'b'
    OUT 'y'
    OUT 'b'
    CALL @blocking_read
    RST
    
cls:
    OUT 0x0c
    RET

; get tow arguments, 2 pointers to strings to compare
; gets one parameter, a number to print
print_number:
    PUSH $RDI
    TEST $RDI, 100
    JST @__print_number__ST_100
    __print_number__BT_100:
        ; get Xxx digit
        DIV $RDI, 100
        ; make printable
        PUSH $RDI
        POP $RD
        ADD $RD, 0x30
        ; print
        OUT
        JMP @__print_number__BT_10
    __print_number__ST_100:
        TEST $RDI, 10
        JST @__print_number__ST_10
        __print_number__BT_10:
            POP $RDI
            PUSH $RDI
            ; get xXx digit
            MOD $RDI, 100
            DIV $RDI, 10
            ; make printable
            PUSH $RDI
            POP $RD
            ADD $RD, 0x30
            ; print 
            OUT
    __print_number__ST_10:
        ; get xxX digit
        POP $RDI
        MOD $RDI, 10
        ; make printable
        PUSH $RDI
        POP $RD
        ; print 
        ADD $RD, 0x30
        OUT
    ; return 
    RET


; gets 1 argument, the initial location for the data
blocking_read:
    PUSH $RDI
    POP $RB
    __blocking_read__get_char:
        GET $RD
        TEST $RD, 0
        JEQ @__blocking_read__get_char
        OUT
        TEST $RD, 10
        JEQ @__blocking_read__return
        __blocking_read__not_zero:
            STOR $RD
            ADD $RB, 1
            JMP @__blocking_read__get_char
    __blocking_read__return:
        MOV $RD, 0
        STOR $RD
        RET
    
; gets 1 argument, the initial position of the data
print:
    PUSH $RDI
    POP $RB
    __print__get_char:
        LOAD $RD
        TEST $RD, 0
        JEQ @__print__ret
        __print__not_zero:
            OUT
            ADD $RB, 1
        JMP @__print__get_char
    __print__ret:
    RET

; get 2 arguments, 2 addresses of null - terminated strings to compare
strcmp:
    __strcmp__load_first_value:
        PUSH $RDI
        POP $RB
        LOAD $RA
        ADD $RDI, 1
    __strcmp__load_second_value:
        PUSH $RSI
        POP $RB
        LOAD $RC
        ADD $RSI, 1
    __strcmp__check_if_equals:
        TSTR $RA, $RC
        JNE @__strcmp__not_equals
    __strcmp__check_if_end:
        ; if it is true it's means that $RC is also \00 because if we got here they both equal
        TEST $RA, 0
        JEQ @__strcmp__equals
        JMP @strcmp
    __strcmp__equals:
        MOV $RA, 1
        JMP @__strcmp__exit
    __strcmp__not_equals:
        MOV $RA, 0
        JMP @__strcmp__exit
    __strcmp__exit:
        RET
